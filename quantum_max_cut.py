# -*- coding: utf-8 -*-
"""quantum-max-cut.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hejhEBHTJ_kNsOtQsAkA9IsYErZgYibv

## **Traffic Optimization Using a Variational Quantum Eigensolver**
by Carla Silva (October 2019) exploring the IBM Q Experience Qiskit Aqua: Experimenting with Max-Cut problem with variational quantum eigensolver
"""

!pip install qiskit

# Commented out IPython magic to ensure Python compatibility.
# useful additional packages 
import matplotlib.pyplot as plt
import matplotlib.axes as axes
# %matplotlib inline
import numpy as np
import networkx as nx

from qiskit import Aer
from qiskit.tools.visualization import plot_histogram
from qiskit.aqua import run_algorithm
from qiskit.aqua.input import EnergyInput
from qiskit.aqua.translators.ising import max_cut, tsp
from qiskit.aqua.algorithms import VQE, ExactEigensolver
from qiskit.aqua.components.optimizers import SPSA
from qiskit.aqua.components.variational_forms import RY
from qiskit.aqua import QuantumInstance

# setup aqua logging
import logging
from qiskit.aqua import set_qiskit_aqua_logging
# set_qiskit_aqua_logging(logging.DEBUG)  # choose INFO, DEBUG to see the log

"""## (a) generating an artificial network simulating a small network in a city with random traffic flow weights"""

# Generating a graph 
from networkx import random_regular_graph
import random
G = random_regular_graph(3,8)
for (u,v,w) in G.edges(data=True):
    w['weight'] = random.randint(0,150)

colors = ['r' for node in G.nodes()]
pos = nx.spring_layout(G)
nx.draw(G, pos, with_labels = True, node_color = colors, edge_color = 'gray' , width = 7, node_size=500, font_size = 8, font_color='black')  #with_labels=true is to show the node number in the output graph
edge_labels = dict([((u, v,), d['weight']) for u, v, d in G.edges(data = True)])
nx.draw_networkx_edge_labels(G, pos, edge_labels = edge_labels, label_pos = 0.5, font_size = 8) #prints weight on all the edges
plt.show()

# Normalization
norm = []
for u,v,d in G.edges(data=True):
	norm.append(d['weight'])

norm = np.array(norm)
norm = (norm - norm.min()) / (norm.max() - norm.min())
for u,v,d in G.edges(data=True):
  d['weight'] = round(norm[u],2)

# Computing the weight matrix from the random graph
n = len(G)
w = np.zeros([n,n])
for u,v,d in G.edges(data=True):
  temp = G.get_edge_data(u,v,default=0)
  if temp != 0:
    w[u,v] = d['weight'] 
print(w)

# Mapping to the Ising problem
qubitOp, offset = max_cut.get_max_cut_qubitops(w)
algo_input = EnergyInput(qubitOp)

# run quantum algorithm with shots
seed = 10598

spsa = SPSA(max_trials=300)
ry = RY(qubitOp.num_qubits, depth=5, entanglement='linear')
vqe = VQE(qubitOp, ry, spsa)

backend = Aer.get_backend('qasm_simulator')
quantum_instance = QuantumInstance(backend, shots=1024, seed_simulator=seed, seed_transpiler=seed)

result = vqe.run(quantum_instance)

"""declarative approach, update the param from the previous cell.
params['backend']['provider'] = 'qiskit.BasicAer'
params['backend']['name'] = 'qasm_simulator'
params['backend']['shots'] = 1024
result = run_algorithm(params, algo_input)
"""

x = max_cut.sample_most_likely(result['eigvecs'][0])
print('energy:', result['energy'])
print('time:', result['eval_time'])
print('max-cut objective:', result['energy'] + offset)
print('solution:', max_cut.get_graph_solution(x))
print('solution objective:', max_cut.max_cut_value(x, w))
plot_histogram(result['eigvecs'][0])

colors = ['r' if max_cut.get_graph_solution(x)[i] == 0 else 'b' for i in range(n)]
pos = nx.spring_layout(G)
nx.draw(G, pos, with_labels = True, node_color = colors, edge_color = 'gray' ,width = 7, node_size=500, font_size = 8, font_color='black')  
edge_labels = dict([((u, v,), d['weight']) for u, v, d in G.edges(data = True)])
nx.draw_networkx_edge_labels(G, pos, with_labels = False, edge_labels = edge_labels, label_pos = 0.5, font_size = 8)

!pip install osmnx

!apt-get install -qq curl g++ make

!curl -L http://download.osgeo.org/libspatialindex/spatialindex-src-1.8.5.tar.gz | tar xz

import os
os.chdir('spatialindex-src-1.8.5')

!./configure

!make

!make install

!pip install rtree

!ldconfig

!sudo apt-get install python-dev graphviz libgraphviz-dev pkg-config

!pip install pygraphviz

"""## (b) generating a real-world city network considering the length of the road links as the weights"""

import osmnx as ox
# Boavista, Porto, Portugal
location_point = (41.158132, -8.629149) 
G = ox.graph_from_point(location_point, distance=300, distance_type='network', network_type='drive')
ox.plot_graph(G)
G = nx.convert_node_labels_to_integers(G)

# Round decimal places
for u,v,d in G.edges(data=True):
	d['length'] = round(d['length'],2)

plt.figure(figsize=(15,10))
colors = ['lightblue' for node in G.nodes()]
pos = nx.nx_agraph.graphviz_layout(G, prog='neato')
nx.draw(G, pos, with_labels = True, node_color = colors, edge_color = 'gray' , node_size=500, width = 7)  
edge_labels = dict([((u, v,), d['length']) for u, v, d in G.edges(data = True)])
nx.draw_networkx_edge_labels(G, pos, edge_labels = edge_labels, label_pos = 0.5, font_size = 8) 
plt.show()

# Normalization
norm = []
for u,v,d in G.edges(data=True):
	norm.append(d['length'])

norm = np.array(norm)
norm = (norm - norm.min()) / (norm.max() - norm.min())

i = 0
for u,v,d in G.edges(data=True):
  d['length'] = round(norm[i],2)
  i = i + 1

# Computing the weight matrix from the random graph
n = len(G)
w = np.zeros([n,n])
for u,v,d in G.edges(data=True):
  temp = G.get_edge_data(u,v,default=0)
  if temp != 0:
    w[u,v] = d['length'] 
print(w)

# Mapping to the Ising problem
qubitOp, offset = max_cut.get_max_cut_qubitops(w)
algo_input = EnergyInput(qubitOp)

# run quantum algorithm with shots
seed = 10598

spsa = SPSA(max_trials=300)
ry = RY(qubitOp.num_qubits, depth=5, entanglement='linear')
vqe = VQE(qubitOp, ry, spsa)

backend = Aer.get_backend('qasm_simulator')
quantum_instance = QuantumInstance(backend, shots=1024, seed_simulator=seed, seed_transpiler=seed)

result = vqe.run(quantum_instance)

"""declarative approach, update the param from the previous cell.
params['backend']['provider'] = 'qiskit.BasicAer'
params['backend']['name'] = 'qasm_simulator'
params['backend']['shots'] = 1024
result = run_algorithm(params, algo_input)
"""

x = max_cut.sample_most_likely(result['eigvecs'][0])
print('energy:', result['energy'])
print('time:', result['eval_time'])
print('max-cut objective:', result['energy'] + offset)
print('solution:', max_cut.get_graph_solution(x))
print('solution objective:', max_cut.max_cut_value(x, w))
plot_histogram(result['eigvecs'][0])

colors = ['r' if max_cut.get_graph_solution(x)[i] == 0 else 'b' for i in range(n)]
pos = nx.spring_layout(G)
nx.draw(G, pos, with_labels = True, node_color = colors, edge_color = 'gray' ,width = 7, node_size=500, font_size = 8, font_color='black')  
edge_labels = dict([((u, v,), d['length']) for u, v, d in G.edges(data = True)])
nx.draw_networkx_edge_labels(G, pos, with_labels = False, edge_labels = edge_labels, label_pos = 0.5, font_size = 8)

# Commented out IPython magic to ensure Python compatibility.
import qiskit.tools.jupyter
# %qiskit_version_table
# %qiskit_copyright